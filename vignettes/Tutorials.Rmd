---
title: "Software tutorials"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Software tutorials}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this tutorial, we demonstrate basic use of the `SpikeInference` package.
`
First we load the package:
```{r}
require(SpikeInference)
```

We first use the `simulate_ar1` function to simulate from an AR(1) model for calcium imaging data according to 
$$Y_t = c_t + \epsilon_t, \epsilon_t \sim N(0, \sigma^2), \; t = 1,\ldots, T,$$ where $$c_t = \gamma  c_{t-1} + z_t, z_t\geq 0,  \; t = 2,\ldots, T.$$ If $z_t>0$, then there is a spike at the $t$th timestep. We denote the locations of true spikes, $\{t:z_t> 0\}$, as $\{\tau_1,\ldots, \tau_K\}$.

In the figure below, we display one such simulation $y_1,\ldots,y_{1,000}$ (gray dots), with  $T=1,000, \sigma = 0.1, \gamma = 0.98, z_t \overset{i.i.d.}{\sim}\text{Poisson}(0.01)$. The true calcium concentration and true spikes are displayed in green lines and vertical bars, respectively.

```{r}
gam <- 0.98
sigma <- 0.3
n_length <- 1000
curr_sim <- simulate_ar1(n = n_length, gam = gam, poisMean = 0.01, sd = sigma, seed = 2)
plot(curr_sim)
```


### $\ell_0$ spike estimation 
In the code below, we call the `spike_estimates` function to estimate spikes using the $\ell_0$-penalized problem with tuning parameter $\lambda=4$. The estimated calcium, $\hat{c_t}$, and the set of estimated spikes, $\{\hat{\tau}_1,\ldots, \hat{\tau}_{\hat{K}}\}$, are displayed in blue lines and vertical bars, respectively.
```{r}
LAMBDA <- 0.7
fit_spike <- spike_estimates(dat = curr_sim$fl, decay_rate = gam, 
                             tuning_parameter = LAMBDA, 
                             functional_pruning_out = FALSE)
plot(fit_spike)
```


The `fit_spike` object now contains spike fit information.
```{r}
str(fit_spike)
```

Importantly, the first five estimated spike locations are printed below.
```{r}
(fit_spike$spikes)[1:5]
```

### $\ell_0$ spike inference 

In this section, we demonstrate how to use our software to obtain $p$-values and confidence intervals for estimated spikes with 2 different window sizes ($h=1$ and $h=10$); for ease of display, we will only consider the first five estimated spikes.

Recall that for a given $\hat\tau_j$, the $p$-value for testing the null hypothesis $H_0: \nu^\top c = 0$ can be expressed as 
$$\mathbb{P}\left(\phi \geq \nu^\top y \;\middle|\; \phi \in \mathcal{S}\cap(0,\infty)\right),$$
where $\mathcal{S}$ is the set of perturbations $\phi$ that leads to an estimated spike at $\hat\tau_j$. 

The code below demonstrates how to use the function `spike_inference`, which estimates spikes *and* performs inference on the estimated spikes for input data. 

#### For h = 1:
```{r}
h <- 1
inference_spike_toy_example_h_1 <- spike_inference(dat = curr_sim$fl, decay_rate = gam,
                                       tuning_parameter = LAMBDA, window_size = h, 
                                       sig2 = sigma*sigma, 
                                       return_conditioning_sets = FALSE,return_ci = TRUE)

knitr::kable(data.frame(estimated_spikes = inference_spike_toy_example_h_1$spikes[1:5], 
                        pvals = inference_spike_toy_example_h_1$pvals[1:5],
                        LCB = inference_spike_toy_example_h_1$LCB[1:5],
                        UCB = inference_spike_toy_example_h_1$UCB[1:5]))

```

#### For h = 10:
```{r}
h <- 10
inference_spike_toy_example_h_10 <- spike_inference(dat = curr_sim$fl, decay_rate = gam,
                                       tuning_parameter = LAMBDA, window_size = h, 
                                       sig2 = sigma*sigma, 
                                       return_conditioning_sets = FALSE,return_ci = TRUE)

knitr::kable(data.frame(estimated_spikes = inference_spike_toy_example_h_10$spikes[1:5], 
                        pvals = inference_spike_toy_example_h_10$pvals[1:5],
                        LCB = inference_spike_toy_example_h_10$LCB[1:5],
                        UCB = inference_spike_toy_example_h_10$UCB[1:5]))
```

We see drastically smaller $p$-values for the five estimated spikes. Since each of the five estimated locations correspond to a true underlying spike, this demonstrates that larger $h$ leads to higher power empirically.

### Miscellaneous functions
In addition to the aforementioned key functions, the package also includes the following helper functions: `construct_v` and `estimate_spike_by_spike_number`.

The function `construct_v` generates the contrast vector $\nu$ for the null hypothesis $H_0:\nu^\top c = 0$. We will demonstrate below that $\nu^\top c$ is indeed the change in calcium in the neighborhood of a given spike $\hat\tau_j$. We consider the case where there is no spike, i.e., the calcium is decaying exponentially, and we would expect $\nu^\top c=0$. In the example below, we set $c_1 = 3$, $c_t = 0.98 c_{t-1}, \; t=2,\ldots, 50$, $\hat\tau_j = 20$, and $h=5$.

```{r}
gam <- 0.98
n <- 50
calcium <- rep(3 * gam ^(0:(n - 1)))
thj <- 20
h <- 5
v <- construct_v(length(calcium), thj, h, gam)
sum(v*calcium)
```
We see that $\nu^\top c$ indeed evaluates to 0, up to machine precision.

While we have taken $\lambda$ to be known in this tutorial, choosing an appropriate $\lambda$ value is critical to the quality of estimated spikes. One possible approach is to use a grid search over a list of $\lambda$ values. The function  `estimate_spike_by_spike_number` provides an alternative by using an iterative method to find the value of $\lambda$ that yields estimated spikes closest in number to the true spikes. 

```{r}
gam <- 0.98
n <- 1000
firing_rate <- 0.05
target_rate <- 0.05
sigma <- 0.1

curr_sim <- simulate_ar1(n = n, gam = gam, poisMean = firing_rate,
                         sd = sigma, seed = 1)

if(sigma>=0.5){
  lam_max = 5
}else{
  lam_max = 1
}

iter_fit_spike <- estimate_spike_by_spike_number(curr_sim, 
                                           decay_rate = gam, target_firing_rate = target_rate, 
                                           lam_min = 1e-7, lam_max = lam_max, max_iters=10,
                                           tolerance=max(5,floor(n*firing_rate*0.05)))
```

The number of true spikes in the simulation is 48.
```{r}
cat("Number of true spikes, " ,length(curr_sim$spikes),"\n")
```

The number of estimated spikes, where $\lambda$ is chosen using `estimate_spike_by_spike_number`, is also 48.
```{r}
cat("Number of estimated spikes, " ,length(iter_fit_spike$spikes),"\n")
```

